<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Funebra™ Bubble Texture v1 — Generative Ink on Paper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- SEO -->
  <meta name="title" content="Funebra™ Bubble Texture v1 — Generative Ink on Paper" />
  <meta name="description"
        content="A Funebra generative art demo inspired by ink-on-paper bubble textures: clustered circles, noisy outlines, scribble shading and paper grain, with WebM export." />
  <meta name="keywords"
        content="Funebra, generative art, ink on paper, bubble texture, bn-points, WebM export, math art" />
  <meta name="author" content="pLabs Entertainment / Funebra" />

  <!-- OpenGraph -->
  <meta property="og:title" content="Funebra™ Bubble Texture v1 — Generative Ink on Paper" />
  <meta property="og:description"
        content="Funebra bubble texture: clustered bn-points, noisy ink outlines, scribble shading and paper grain, rendered in the browser." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://funebra.github.io/assets/og/funebra-bubble-texture-v1.png" />
  <meta property="og:url" content="https://funebra.github.io/art/experiment/bubble-texture/" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Funebra™ Bubble Texture v1 — Generative Ink on Paper" />
  <meta name="twitter:description"
        content="Generative ink-on-paper texture built from bn-point bubbles, noisy outlines, scribble shading and paper grain." />
  <meta name="twitter:image" content="https://funebra.github.io/assets/og/funebra-bubble-texture-v1.png" />

  <style>
    :root {
      --bg: #050712;
      --panel: #0b0f20;
      --accent: #ff3c7f;
      --accent-soft: #ffb3d2;
      --border: #2b3044;
      --text: #f5f5ff;
      --muted: #a3a7cf;

      --paper: #f6f4f0;
      --paper-wash: #e7d3ab;
      --ink: #201612;
      --ink-soft: #aaa095;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background:
        radial-gradient(circle at top, #181d36 0, #050712 60%, #010208 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
    }

    .shell {
      width: 100%;
      max-width: 1200px;
      background: linear-gradient(145deg, #060818, #0b0f20);
      border-radius: 1.5rem;
      border: 1px solid var(--border);
      box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      padding: 1.5rem 1.5rem 1.8rem;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(260px, 1fr);
      gap: 1.5rem;
    }

    @media (max-width: 900px) {
      .shell {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
      margin-bottom: 0.2rem;
    }

    header h1 {
      font-size: 1.3rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .canvas-wrap {
      position: relative;
      border-radius: 1.2rem;
      background: radial-gradient(circle at top, #fdfbf6 0, #d3c4a5 55%, #b49b73 100%);
      padding: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.2),
        0 25px 45px rgba(0, 0, 0, 0.7);
    }

    canvas {
      background: var(--paper);
      border-radius: 0.6rem;
      box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.26),
        inset 0 0 30px rgba(0, 0, 0, 0.12);
      max-width: 100%;
    }

    .panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 0.5rem 0.2rem 0.2rem;
    }

    .panel h2 {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
    }

    p {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--muted);
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.3rem;
    }

    button {
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, var(--accent) 0, #b42360 40%, #531332 100%);
      color: white;
      font-size: 0.8rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.2s ease;
      box-shadow: 0 7px 18px rgba(0, 0, 0, 0.45);
    }

    button.secondary {
      background: linear-gradient(145deg, #0f1325, #131933);
      color: var(--accent-soft);
    }

    button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.65);
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.4rem;
    }

    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0.22rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(12, 18, 40, 0.85);
    }

    .meta {
      font-size: 0.75rem;
      color: var(--muted);
      border-top: 1px solid #181c33;
      padding-top: 0.6rem;
      margin-top: 0.3rem;
    }

    .meta code {
      font-size: 0.72rem;
      background: #0b1021;
      padding: 0.08rem 0.3rem;
      border-radius: 4px;
      border: 1px solid #20253b;
    }

    a#downloadLink {
      display: inline-block;
      margin-top: 0.35rem;
      font-size: 0.78rem;
      color: var(--accent-soft);
      text-decoration: none;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    a#downloadLink.visible {
      opacity: 1;
      pointer-events: auto;
      text-decoration: underline;
    }

    .status {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 0.3rem;
    }
  </style>
</head>
<body>
<div class="shell">
  <header>
    <h1>Funebra™ Bubble Texture v1</h1>
    <span>Ink-on-paper style · bn-point clusters · WebM export</span>
  </header>

  <div class="canvas-wrap">
    <canvas id="funebraCanvas" width="800" height="600"></canvas>
  </div>

  <aside class="panel">
    <section>
      <h2>Dynamic Math Texture</h2>
      <p>
        A generative interpretation of the ink-on-paper “bubble” drawings:
        overlapping bn-points become clusters, outlines get noisy, shading turns
        into looping scribbles and a soft paper grain ties everything together.
      </p>
      <div class="btn-row">
        <button id="regenBtn">Regenerate Texture</button>
        <button id="startRecBtn" class="secondary">Start WebM Capture</button>
        <button id="stopRecBtn" class="secondary">Stop &amp; Finalize</button>
      </div>
      <a id="downloadLink" href="#" download="funebra-bubble-texture.webm">
        Download WebM render
      </a>
      <div class="status" id="statusText">Idle · 0 bubbles rendered.</div>
      <div class="badge-row">
        <span class="badge">bn-points</span>
        <span class="badge">noisy outlines</span>
        <span class="badge">scribble shading</span>
        <span class="badge">paper grain</span>
      </div>
    </section>

    <section class="meta">
      Palette:
      <code>#f6f4f0</code> paper,
      <code>#e7d3ab</code> wash,
      <code>#201612</code> ink,
      <code>#aaa095</code> soft ink.
      <br /><br />
      JS entry:
      <code>Funebra.bubbleTexture.init(canvas)</code>,
      <code>Funebra.bubbleTexture.regenerate()</code>.
    </section>
  </aside>
</div>

<script>
  // --- Funebra Bubble Texture module -------------------------------------
  // --- funebra-bubble-texture.js 
  const Funebra = window.Funebra || {};
  Funebra.bubbleTexture = (function () {
    const cfg = {
      numBubbles: 160,
      minR: 0.02,
      maxR: 0.08,
      paper: '#f6f4f0',
      ink: '#201612',
      inkSoft: '#aaa095'
    };

    let canvas, ctx, bubbles = [];
    let frame = 0;

    // simple seeded RNG for soft animation changes
    let seed = 1;
    function rand() {
      // LCG
      seed = (seed * 1664525 + 1013904223) >>> 0;
      return seed / 0xFFFFFFFF;
    }

    function generateBubbles() {
      bubbles = [];
      const count = cfg.numBubbles;
      const seedsCount = Math.max(4, Math.floor(count / 10));

      // seed centers
      for (let i = 0; i < seedsCount; i++) {
        bubbles.push({
          id: 'bn' + i,
          x: Math.random(),
          y: Math.random(),
          r: cfg.minR + Math.random() * (cfg.maxR - cfg.minR)
        });
      }

      while (bubbles.length < count) {
        const parent = bubbles[Math.floor(Math.random() * bubbles.length)];
        const angle = Math.random() * Math.PI * 2;
        const dist = parent.r * (0.8 + Math.random() * 1.5);
        const nx = parent.x + Math.cos(angle) * dist;
        const ny = parent.y + Math.sin(angle) * dist;
        if (nx < -0.05 || nx > 1.05 || ny < -0.05 || ny > 1.05) continue;

        const r = parent.r * (0.6 + Math.random() * 0.9);
        bubbles.push({
          id: 'bn' + bubbles.length,
          x: nx,
          y: ny,
          r
        });
      }
    }

    function drawNoisyCircle(cx, cy, r, t) {
      const passes = 3;
      ctx.strokeStyle = cfg.ink;
      for (let p = 0; p < passes; p++) {
        ctx.beginPath();
        let first = true;
        for (let a = 0; a <= Math.PI * 2 + 0.1; a += 0.08) {
          const noise =
            (Math.sin(a * 7.3 + t * 0.7 + p * 0.4) * 0.5 + (rand() - 0.5)) *
            r * 0.12;
          const rr = r + noise;
          const x = cx + Math.cos(a) * rr;
          const y = cy + Math.sin(a) * rr;
          if (first) {
            ctx.moveTo(x, y);
            first = false;
          } else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
    }

    function shadeBubble(cx, cy, r, intensity, t) {
      const strokes = Math.floor(60 * intensity);

      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 0.5;

      for (let i = 0; i < strokes; i++) {
        const baseAngle =
          Math.PI * 0.7 +
          Math.random() * Math.PI * 0.6 +
          0.2 * Math.sin(t * 0.4 + i * 0.1);
        const rr = r * (0.35 + Math.random() * 0.65);
        let x = cx + Math.cos(baseAngle) * rr;
        let y = cy + Math.sin(baseAngle) * rr;

        ctx.beginPath();
        ctx.moveTo(x, y);

        const steps = 10 + Math.floor(Math.random() * 18);
        for (let s = 0; s < steps; s++) {
          const ang = baseAngle + (Math.random() - 0.5) * 1.2;
          const stepR = r * 0.18;
          x += Math.cos(ang) * stepR * (0.4 + Math.random());
          y += Math.sin(ang) * stepR * (0.4 + Math.random());

          const dx = x - cx;
          const dy = y - cy;
          const dist2 = dx * dx + dy * dy;
          if (dist2 > r * r) {
            const d = Math.sqrt(dist2) || 1;
            x = cx + (dx / d) * r * 0.93;
            y = cy + (dy / d) * r * 0.93;
          }

          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      ctx.globalAlpha = 1.0;
    }

    function addPaperGrain() {
      const { width, height } = canvas;
      const img = ctx.getImageData(0, 0, width, height);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        const n = (Math.random() - 0.5) * 6; // -3..3
        d[i] += n;
        d[i + 1] += n;
        d[i + 2] += n;
      }
      ctx.putImageData(img, 0, 0);
    }

    function render(t) {
      if (!canvas || !ctx) return;
      const W = canvas.width;
      const H = canvas.height;
      const minDim = Math.min(W, H);

      // warm paper base
      const grd = ctx.createLinearGradient(0, 0, 0, H);
      grd.addColorStop(0, '#fbf7f0');
      grd.addColorStop(1, '#ead7b4');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      ctx.strokeStyle = cfg.ink;
      ctx.lineWidth = 0.8;

      // sort by radius so smaller bubbles on top
      const sorted = [...bubbles].sort((a, b) => a.r - b.r);

      // noise seed changed slowly
      seed = 1 + Math.floor(t * 10);

      sorted.forEach((b, idx) => {
        const cx = b.x * W;
        const cy = b.y * H;
        const r = b.r * minDim;

        const intensity =
          0.25 +
          0.6 *
            (0.5 +
              0.5 *
                Math.sin(
                  (b.x + b.y) * 5.3 + t * 0.5 + idx * 0.13
                ));

        ctx.strokeStyle = cfg.inkSoft;
        shadeBubble(cx, cy, r, intensity, t);
        ctx.strokeStyle = cfg.ink;
        drawNoisyCircle(cx, cy, r, t);
      });

      addPaperGrain();
      frame++;
      if (statusText) {
        statusText.textContent =
          'Frame ' + frame + ' · ' + bubbles.length + ' bn-bubbles.';
      }
    }

    function loop(ts) {
      const t = ts * 0.001;
      render(t);
      requestAnimationFrame(loop);
    }

    function init(c) {
      canvas = c;
      ctx = canvas.getContext('2d');
      generateBubbles();
      frame = 0;
      requestAnimationFrame(loop);
    }

    function regenerate() {
      generateBubbles();
      frame = 0;
    }

    return { init, regenerate, get bubbles() { return bubbles; } };
  })();

  // --- Bootstrap + WebM recording -----------------------------------------
  const canvas = document.getElementById('funebraCanvas');
  const regenBtn = document.getElementById('regenBtn');
  const startRecBtn = document.getElementById('startRecBtn');
  const stopRecBtn = document.getElementById('stopRecBtn');
  const downloadLink = document.getElementById('downloadLink');
  const statusText = document.getElementById('statusText');

  Funebra.bubbleTexture.init(canvas);

  regenBtn.addEventListener('click', () => {
    Funebra.bubbleTexture.regenerate();
  });

  let mediaRecorder = null;
  let recordedChunks = [];

  startRecBtn.addEventListener('click', () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') return;

    const stream = canvas.captureStream(30); // 30fps
    const options = { mimeType: 'video/webm;codecs=vp9' };

    try {
      mediaRecorder = new MediaRecorder(stream, options);
    } catch (e) {
      alert('MediaRecorder not supported or codec not available in this browser.');
      return;
    }

    recordedChunks = [];
    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.classList.add('visible');
      statusText.textContent =
        'Capture complete · ' +
        (blob.size / (1024 * 1024)).toFixed(2) +
        ' MB WebM ready.';
    };

    mediaRecorder.start();
    downloadLink.classList.remove('visible');
    statusText.textContent = 'Recording… Rendering WebM from canvas stream.';
  });

  stopRecBtn.addEventListener('click', () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      statusText.textContent = 'Finalizing WebM…';
    }
  });

  // resize helper: keep 4:3 inside wrapper
  function handleResize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const width = Math.min(rect.width - 10, 900);
    const height = (width * 3) / 4;
    canvas.width = width;
    canvas.height = height;
  }

  window.addEventListener('resize', handleResize);
  handleResize();
</script>
</body>
</html>
